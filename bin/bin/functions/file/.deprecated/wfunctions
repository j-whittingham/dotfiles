#!/usr/bin/dash
# sdothum - 2016 (c) wtfpl

# File
# ══════════════════════════════════════════════════════════════════════════════

# ............................................................. watchman library

usage() {
  echo "usage: . wfunctions <path> <name> <command>"
  exit 1
}

[ $# -lt 3 ] && usage

# watchman
ROOT=$1; shift
NAME=$1; shift
CMD=$@

CACHEDIR=${CACHEDIR:-$HOME/.cache}
SESSION=${SESSION:-$HOME/.session}
WATCH=$CACHEDIR/$NAME
IGNORE=$WATCH:ignore
WNAME=${WNAME:-$SESSION/$NAME}
VERBOSE=$WNAME:verbose
LOG=/tmp/$NAME.log
SCAN=5

[ -e $WATCH ] || touch $WATCH

pstat watchman && exec cat $WATCH

info() {
  name=$(echo $file | exclude | sed "s|$ROOT/||")
  if [ -n "$name" ] ;then
    trace "$1 ${ROOT##*/} ${__YELLOW}$name" >>$LOG
    notify X "$1 ${ROOT##*/}" "$name"
  fi
}

register() {
  if [ -f "$file" ] ;then
    ([ -e $VERBOSE ] || [ ! -e $WNAME ]) && info Register
    grep -qx "${file%/*}" $WATCH || echo ${file%/*} >>$WATCH
  fi
  unset file
}

queue() {
  for i in $@ ;do
    [ -d "$ROOT/${i%/*}" ] && { register; file="$ROOT/$i"; } || file="$file $i"
  done
  register
}

# trap random watchman initialization flooding and reset watch queue
watch() {
  notify X low 'Watchman' "$(watchman -- trigger $ROOT $NAME -- $CMD | sed '/[{}]/d; s/^ *//g; s/"//g; s/,$//')"
  touch $IGNORE
  trap "rm -f $IGNORE" EXIT
  scan=true
  while [ $scan ] ;do
    unset scan
    for i in $(seq 1 $SCAN) ;do
      sleep 1; pkill -f "${CMD%% *} .*/.*" && scan=true
    done
    # adjust for initialization latency
    [ $scan ] || { [ -s $WATCH ] || scan=true; }
  done
  notify X 3 critical 'Watchman' "Triggers cleared: $(cat $WATCH | wc -l)"
  >$WATCH
}

# vim: set ft=sh: #
